#!perl
use 5.020;
use Filter::signatures;
use feature 'signatures';
no warnings 'experimental::signatures';

use Filesys::DB;
use DBIx::RunSQL;
use Getopt::Long;
use YAML 'LoadFile';
use PerlX::Maybe;
use Text::Table;

use Lingua::Stem::Cistem;

GetOptions(
    'mountpoint|m=s' => \my $mountpoint,
    'alias|a=s' => \my $mount_alias,
    'config|f=s' => \my $config_file,
);

my $console_output=1;

my $config = {};
my $user_config = {};
if(! defined $config_file ) {
    if ( 'filesys-db.yaml' ) {
        $config_file = 'filesys-db.yaml';
    } else {
        $user_config = {
            mountpoints => [
                {
                  alias => $mount_alias // '${MOUNT}',
                  directory => $mountpoint //  $ARGV[0],
                }
            ],
        }
    }
}
if( $config_file ) {
    $user_config = LoadFile( $config_file );
};
$user_config->{mountpoints} //= {};
$config->{mountpoints} = $user_config->{mountpoints};

my $store = Filesys::DB->new(
    mountpoints => {
        %{ $config->{mountpoints} },
        maybe $mount_alias => $mountpoint,
    },
);

my @docs = $store->_inflate_sth( $store->entries( undef, <<'SQL' ));
        html is not null
    and mime_type='application/pdf'
SQL

use DBD::SQLite::Constants ':fts5_tokenizer';
use locale;

# Another horrible idea: Parsing the text in an HTML file (hopefully
# generated by Tika) using a regular expression
# We convert the HTML to ['text',startpos,endpos]
sub locale_tika_tokenizer { # see also: Search::Tokenizer
  return sub {
      my ( $ctx, $string, $tokenizer_context_flags ) = @_;
    #my $regex      = qr/\w+/;
    #my $term_index = 0;
    #

    my @res;
    # Find next non-tag chunk:
    my $start_ofs;
    while( $string =~ /(?:^|>)([^<>]*)(?:<|$)/g ) {
        # Extract tokens from that part
        $start_ofs = $-[1];
        my $run = $1;
        while( $run =~ /(\w+)/g ) {
            # push @res, [$1,$start_ofs+$-[0], $+[0]];
            my ($start, $end) = ($-[0], $+[0]);
            #my $term = substr($string, $start, my $len = $end-$start);
            my $term = "$1";
            $start += $start_ofs;
            $end   += $start_ofs;

            # say sprintf "%s <%s>", $term, substr( $string, $start, $end-$start);

            my $flags = 0;
            DBD::SQLite::db::fts5_xToken($ctx,$flags,$term,$start,$end);

            my @collocated = Lingua::Stem::Cistem::stem( $term );

            # also push synonyms here

            $flags = FTS5_TOKEN_COLOCATED;
            for my $t (@collocated) {
                if( $t ne $term ) {
                    DBD::SQLite::db::fts5_xToken($ctx,$flags,$t,$start,$end);
                }
            }

        }
    }
  };
}

# create fts table
$store->dbh->do(<<"") or die DBI::errstr;
    drop table if exists filesystem_entry_fts5;

# This should happen in create.sql ...
$store->dbh->do(<<"") or die DBI::errstr;
  CREATE VIRTUAL TABLE filesystem_entry_fts5
        USING fts5(content, entry_id UNINDEXED, tokenize="perl 'main::locale_tika_tokenizer'")

for my $doc (@docs[0..9]) {
    my( $entry_id) = $doc->{ 'entry_id' };
    my( $html) = $doc->{ content }->{ html };
    my $tmp_res = $store->selectall_named(<<'', $entry_id, $html )->[0];
        INSERT INTO filesystem_entry_fts5(content, entry_id)
             VALUES(:html, :entry_id)

}

my $search = 'anrechenbar';

sub left_ell($str,$len) {
    #warn $str;
    if( length($str) > $len-3 ) {
        $str = '...'.substr( $str, length($str)-$len+3, $len-3 );
    }
    return $str
}

sub mid_ell($str,$len) {
    #warn $str;
    if( length($str) > $len-6 ) {
        $str = '...'.substr( $str, length($str)-$len+6, $len-6 ).'...';
    }
    return $str
}

sub right_ell($str,$len) {
    #warn $str;
    if( length($str) > $len-3 ) {
        $str = substr( $str, 0, $len-3 ).'...';
    }
    return $str
}

my $tmp_res = $store->selectall_named(<<'', $search);
    SELECT content
         , entry_id
         , highlight(filesystem_entry_fts5, 0, '<-mark->', '</-mark->') as snippet
      FROM filesystem_entry_fts5-- (:search)
      where content MATCH :search
  order by rank

# prepare for output
for (@$tmp_res) {
    $_->{snippet} =~ s!\A(.*?)<-mark->!left_ell($1,15)."<-mark->"!ems;
    $_->{snippet} =~ s!</-mark->(.*?)<-mark->!mid_ell($1,15)."<-mark->"!gems;
    $_->{snippet} =~+ s!</-mark->(.*?)\z!right_ell($1,15)!ems;

    if( $console_output ) {
        $_->{snippet} =~ s!</?-mark->!!g;
    }
}

my $out = Text::Table->new('entry_id','snippet');
$out->load(
    map { [@{$_}{qw(entry_id snippet)}] } @{ $tmp_res }
);
print $out;

